[{:db/id #db/id[:db.part/db]
  :db/ident :transaction-test/one-value
  :db/valueType :db.type/uuid
  :db/cardinality :db.cardinality/one
  :db/doc "A one-cardinality value that happens to be a UUID."
  :db.install/_attribute :db.part/db}

 {:db/id #db/id[:db.part/db]
  :db/ident :transaction-test/many-value
  :db/valueType :db.type/uuid
  :db/cardinality :db.cardinality/many
  :db/doc "A many-cardinality value that happens to be a UUID."
  :db.install/_attribute :db.part/db}

 {:db/id #db/id[:db.part/db]
  :db/ident :transaction-test/one-ref
  :db/valueType :db.type/ref
  :db/cardinality :db.cardinality/one
  :db/doc "A one-cardinality value that is a ref"
  :db.install/_attribute :db.part/db}

 {:db/id #db/id[:db.part/db]
  :db/ident :transaction-test/many-ref
  :db/valueType :db.type/ref
  :db/cardinality :db.cardinality/many
  :db/doc "A many-cardinality value that is a ref"
  :db.install/_attribute :db.part/db}

 {:db/id #db/id[:db.part/db]
  :db/ident :transaction-test/one-ref-comp
  :db/valueType :db.type/ref
  :db/cardinality :db.cardinality/one
  :db/doc "A one-cardinality value that is a ref"
  :db/isComponent true
  :db.install/_attribute :db.part/db}

 {:db/id #db/id[:db.part/db]
  :db/ident :transaction-test/many-ref-comp
  :db/valueType :db.type/ref
  :db/cardinality :db.cardinality/many
  :db/doc "A many-cardinality value that is a ref"
  :db/isComponent true
  :db.install/_attribute :db.part/db}


 {:db/id #db/id [:db.part/user]
  :db/ident :transact
  :db/fn #db/fn
  {:lang "clojure"
   :params [db eid rel old-value new-value]
   :code (let [entity   (d/entity db eid)
               relation (d/entity db rel)
               ->set (fn [maybe-set]
                       (cond
                         (instance? datomic.Entity maybe-set) #{maybe-set}
                         (coll? maybe-set) (set maybe-set)
                         (nil?  maybe-set) #{}
                         :else             #{maybe-set}))
               old-values (->set old-value)
               new-values (->set new-value)
               derefer (if (= :db.type/ref (:db/valueType relation))
                         :db/id
                         identity)
               existing-values (set (map derefer (->set (get entity rel))))]
           (when-not (= old-values existing-values)
             (throw (java.util.ConcurrentModificationException.
                     (str "old-values do not match existing values: "
                          "old-values: " (pr-str old-values) " "
                          "existing-values: " (pr-str existing-values)))))

           (concat
            (for [val old-values
                  :when (not (contains? new-values val))]
              [:db/retract eid rel val])
            (for [val new-values
                  :when (not (contains? old-values val))]
              [:db/add eid rel val])))}}

 ]
